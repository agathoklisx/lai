/* if a compilation unit is the main file, also argv[0] keeps this name */
var mypath = __FILE__;

/* 'trait', 'beg' and 'end' */
trait GetAgeTrait beg
  get_age () beg
    return this.age;
  end
end

/* 'class', 'beg', '{' and a mix with 'end' and '}' */
class Person beg
  /* 'use' */
  use GetAgeTrait;

  /* init and this */
  init (name, age) {
    this.age = age;
    this.name = name;
  end
}

/* instance and 'var' */
var pers = Person ("eva", 14);
/* (expression) into expressions and StringType methods */
assert ("EVA" == ((pers.name.upper()).lower ()).upper ());
assert (14 == pers.get_age ());

/* assign 'os' to 'System' (delivered by the library) */
var os = System;

/* 'false' */
var test = false;
/* 'if', 'then', 'not', '!', 'or', 'orelse', and os variable as System */
if (not test or !test) then
  print ("ok");
orelse then
  print ("not ok");
  os.exit (1);
end

test = 1;

/* 'is', 'and', '==', '!=', 'isnot' */
if (test is 1 and test == 1 and test != 2 and test isnot 2) then
  print ("ok");
orelse then
  print ("not ok");
  os.exit (1);
end

/* this use of 'orelse' is fine */
if (true) then
  print ("ok");
orelse
  print ("never reached here");
/* but the whole expression is missing an 'end'. This is ambiguity, and so avoided */

/* 'for', 'do', 'orelse if' */
for (var i = 0; i < 16; ++i) do
  if (i % 3 == 0 and i % 5 == 0) then
    assert (i == 0 or i == 15);
  orelse if (i % 3 == 0) then
    assert (i == 3 or i == 6 or i == 9 or i == 12);
  orelse then
    if (i % 2) print ("ok");
    /* this 'if' use however is nice and sane, though parsers might be confused */
  end
end

/* function declaration */
def fun () beg
  return true;
end
assert (fun () == true);

trait basename beg
   basename (name, delim) beg
     return name.split(delim).pop();
   end
end

class stdlib beg
  use basename;
end

class Path < stdlib beg
  init () beg
    this.delim = '/';
  end

  basename (name) beg
    return super.basename (name, this.delim);
  end

  dirname (name) beg
    var p = name.split(this.delim);
    var len = p.len();
    if (len is 1) then return "."; end
    return p[:len - 1].join(this.delim);
  end

  split (name) beg
    return name.split(this.delim);
  end
end

/* this seems to work, but certainly not sane practice */
var Path = Path ();

var cur_cwd = System.getCWD();

var basename = Path.basename (mypath);
var dirname = Path.dirname (mypath);

assert (dirname + "/" + basename == mypath);
assert (System.setCWD (dirname) == 0);
assert (System.getCWD () == cur_cwd + "/" + dirname);

/* 'import' gets a string for filename */
import "test-import.lai";

assert (System.setCWD ("/nonEXISTANT") == -1);
assert (System.setCWD (cur_cwd) == 0);
assert (System.getCWD () == cur_cwd);

/* but it can accept an expression also (this form is preferable) */
import (dirname + "/test-import-as_expression.lai");

/* __FILE__ always refer to the last imported file, so it needs to copy
 * by every unit in a unique variable, but see test-import.lai for details */
assert (__FILE__ ==  dirname + "/test-import-as_expression.lai");

/* or provided by the class */
var __ = TestImportA ();
assert (__.ns () == "test-import.lai");

/* change reference */
__ = TestImportB ();
assert (__.ns () == "test-import-as_expression.lai");

import (dirname + "/book_tests.lai");

/* len() method */
var s = set();
s.add ("alpha");
s.add ("vita");
assert (s.len() == 2);
assert ("asdfg".len() == 5);
assert ("ασδφγ".len() == 10);
assert ([1, 2, 3].len() == 3);
assert ({"one": 1, "two": 2}.len() == 2);

/* type() and Types */
assert (type("as") == "string");
assert (type(s) == "set");
assert (type([1]) == "list");
assert (type({"one": 1}) == "dict");
assert (type(fun) == "function");
assert (type(Path) == "Path");         /* This is why the above is not good practice */
assert (type(TestImportA) == "class"); /* like in this case */
assert (type(GetAgeTrait) == "trait");
assert (type(print) == "native");
assert (type(Path.basename) == "method");
assert (type(true) == "bool");
assert (type(1) == "number");
assert (type(1.5) == "number");
assert (type(nil) == "nil");

import (dirname + "/semantics.lai");
import (dirname + "/http.lai");
import (dirname + "/book_tests.lai");

/* buggy 'forever' loop, as there is np 'break', so and as the last statement,
   is finishing the test for now by calling exit

var ii = 0;
forever do
  if (++ii > 3) then os.exit (0); end
end
*/
print ("Done");
