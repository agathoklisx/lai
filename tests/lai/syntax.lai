var mypath = __FILE__;
/* if a compilation unit is the main file, also argv[0] keeps this name */

/* 'trait', 'beg' and 'end' */
trait GetAgeTrait beg
  get_age () beg
    return this.age;
  end
end

/* 'class', 'beg', '{' and a mix with 'end' and '}' */
class Person beg
  /* 'use' */
  use GetAgeTrait;

  /* init and this */
  init (name, age) {
    this.age = age;
    this.name = name;
  end
}

/* instance and 'var' */
var pers = Person ("eva", 14);
/* (expression) into expressions and StringType methods */
assert ("EVA" == ((pers.name.upper()).lower ()).upper ());
assert (14 == pers.get_age ());

/* assign 'os' to 'System' (delivered by the library) */
var os = System;

/* 'false' */
var test = false;
/* 'if', 'then', 'not', '!', 'or', 'orelse', and os variable as System */
if (not test or !test) then
  print ("ok");
orelse then
  print ("not ok");
  os.exit (1);
end

test = 1;

/* 'is', 'and', '==', '!=', 'isnot' */
if (test is 1 and test == 1 and test != 2 and test isnot 2) then
  print ("ok");
orelse then
  print ("not ok");
  os.exit (1);
end

/* this use of 'orelse' is fine */
if (true) then
  print ("ok");
orelse
  print ("never reached here");
/* but the whole expression is missing an 'end'. This is ambiguity, and so avoided */

/* 'for', 'do', 'orelse if' */
for (var i = 0; i < 16; ++i) do
  if (i % 3 == 0 and i % 5 == 0) then
    assert (i == 0 or i == 15);
  orelse if (i % 3 == 0) then
    assert (i == 3 or i == 6 or i == 9 or i == 12);
  orelse then
    if (i % 2) print ("ok");
    /* this 'if' use however is nice and sane, though parsers might be confused */
  end
end

/* function declaration */
def fun () beg
  return true;
end
assert (fun () == true);

trait basename beg
   basename (name, delim) beg
     return name.split(delim).pop();
   end
end

class stdlib beg
  use basename;
end

class Path < stdlib beg
  init () beg
    this.delim = '/';
  end

  basename (name) beg
    return super.basename (name, this.delim);
  end

  dirname (name) beg
    var p = name.split(this.delim);
    var num = len (p);
    if (num is 1) then return p[0]; end
    return p[:num - 1].join(this.delim);
  end

  split (name) beg
    return name.split(this.delim);
  end
end

/* this seems to work */
var Path = Path ();

var cur_cwd = System.getCWD();

var basename = Path.basename (mypath);
var dirname = Path.dirname (mypath);

assert (dirname + "/" + basename == mypath);
assert (System.setCWD (dirname) == 0);
assert (System.getCWD () == cur_cwd + "/" + dirname);

/* 'import' gets a string for filename */
import "test-import.lai";

assert (System.setCWD (cur_cwd) == 0);
assert (System.getCWD () == cur_cwd);

/* but it can accept an expression also (this form is preferable) */
import (dirname + "/test-import-as_expression.lai");

/* __FILE__ always refer to the last imported file, so it needs to copy
 * by every unit in a unique variable, but see test-import.lai for details */
assert (__FILE__ ==  dirname + "/test-import-as_expression.lai");

/* or provided by the class */
var __ = TestImportA ();
assert (__.ns () == "test-import.lai");

/* change reference */
__ = TestImportB ();
assert (__.ns () == "test-import-as_expression.lai");

/* buggy 'forever' loop, as there is np 'break', so and as the last statement,
   is finishing the test for now by calling exit */
var ii = 0;
forever do
  if (++ii > 3) then os.exit (0); end
end
